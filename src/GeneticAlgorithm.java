import java.util.*;
import java.util.concurrent.ThreadLocalRandom;  // for mutation
import java.util.stream.IntStream;

public class GeneticAlgorithm {

    // 2D-Array of distances between every pair of cities. Used as an optimisation,
    // in order not to calculate a distance every time it is needed.
    private static double distanceMatrix[][];

    public static void GA(ArrayList<City> cities){
        // the number of cities that need to be visited
        int pathLength = cities.size();
        // the number of chromosomes which will be generated
        int populationSize = 100;
        // the number of chromosomes that will be generated from crossover as a percentage of the population
        double crossoverRate = 0.8;
        // the number of chromosomes that will be generated from crossover
        int crossoverSize = (int) (populationSize * crossoverRate);
        // the probability that a chromosome can have a random mutation
        double mutationRate = 0.05;
        // the number of generations
        int generations = 5000;

        // Initialising the distance matrix using the initialiseDistanceMatrix method
        initialiseDistanceMatrix(cities);

        // Generating the Initial Population
        ArrayList<Chromosome> population = generatePopulation(cities, pathLength, populationSize);

        // The following is done for each generation of the population
        for (int i = 0; i < generations; i++) {
            // calculating the fitness of every chromosome in the current generation
            calculateFitnessOfPopulation(population);
            // sort the population so that the chromosomes with the highest fitness are at the start of the list
            Collections.sort(population);
            // call the method which performs crossover on the population
            Set<Chromosome> children = crossoverPopulation(population, populationSize, crossoverSize);
            // carry out mutation on the children of the current population
            children.addAll( mutatePopulation(children, mutationRate) );

            // evolve the population
            population.addAll(children);
            ArrayList<Chromosome> currentGeneration = new ArrayList<>(population);
            ArrayList<Chromosome> nextGeneration = evolvePopulation(currentGeneration, populationSize, cities, pathLength);
            population = new ArrayList<>(nextGeneration);
        }

        // find the fittest chromosome
        Chromosome fittestChromosome = population.get(0);
        double maxFitness = population.get(0).fitness;
        for (Chromosome c : population) {
            if (c.fitness > maxFitness) {
                maxFitness = c.fitness;
                fittestChromosome = c;
            }
        }
        // display the path and distance of the fittest chromosome
        System.out.println(fittestChromosome.getPath());
        System.out.println("Total Route Distance: " + routeDistance(fittestChromosome));

        //printPopulation(population);
    }


    // this method calculates the distance between every pair of cities.
    // when storing all the distances inside an array, the algorithms can check for the distance from this array
    // in constant time, instead of calculating it every single time.
    private static void initialiseDistanceMatrix(ArrayList<City> cities) {
        // initialising the distanceMatrix as a new empty square 2D array, according to how many cities there are
        distanceMatrix = new double[cities.size()][cities.size()];

        for (int i = 0; i < cities.size(); i++) {
            for (int j = 0; j < cities.size(); j++) {
                // check if the distance between 2 cities has already been calculated
                if (distanceMatrix[i][j] == 0.0) {
                    // calculate the distance between cities i and j
                    distanceMatrix[i][j] = Location.distance(cities.get(i).location, cities.get(j).location);
                    // set the distance between cities j and i to the distance between cities i and j,
                    // as these will always be equal given that this is a Symmetric TSP
                    distanceMatrix[j][i] = distanceMatrix[i][j];
                }
            }
        }
    }


    // Method which generates a population using a combination of the Nearest Neighbour Algorithm and Randomly.
    private static ArrayList<Chromosome> generatePopulation(ArrayList<City> cities, int pathLength, int populationSize) {
        // generating part of the initial population using a Nearest Neighbour Algorithm
        int nnPopulationSize = (int) (0.1*populationSize);
        // if the required number of chromosomes to be generated by the NN Algorithm is greater then the number of cities
        // then set the required number of chromosomes to the number of cities
        if (nnPopulationSize > cities.size()) {
            nnPopulationSize = cities.size();
        }
        ArrayList<Chromosome> nnPopulation = generateNearestNeighbourPopulation(pathLength, nnPopulationSize);

        // generating the rest of the initial population randomly
        int randomPopulationSize = populationSize - nnPopulationSize;
        ArrayList<Chromosome> randomPopulation = new ArrayList<>();
        randomPopulation.addAll( generateRandomPopulation(pathLength, randomPopulationSize) );

        // Combining the 2 parts of the population into one initial population
        ArrayList<Chromosome> population = new ArrayList<>();
        population.addAll(nnPopulation);
        population.addAll(randomPopulation);

        return population;
    }
    // Method which returns an initial population using the Nearest Neighbour Algorithm
    private static ArrayList<Chromosome> generateNearestNeighbourPopulation(int pathLength, int nnPopulationSize){
        // declaring the arraylist of chromosomes which will store the
        ArrayList<Chromosome> nnPopualtion = new ArrayList<>();

        // declaring a set which will contain all the starting cities that will be used for the population
        Set<Integer> startingCities = new HashSet<>();
        // initialising the set of startingCities with random cities. It being a set no duplicates are allowed
        while (startingCities.size() < nnPopulationSize) {
            startingCities.add(ThreadLocalRandom.current().nextInt(0, pathLength));
        }

        // An ArrayList with all the cityIDs which can be copied to keep track of visited/unvisited cities
        ArrayList<Integer> cities = new ArrayList<>();
        for (int i = 0; i < pathLength; i++) {
            cities.add(i);
        }

        // for every starting city
        for (Integer startingCity : startingCities) {
            // set the currentCity as the Starting City
            int currentCity = startingCity;
            // Declare a new chromosome to store this new path
            Chromosome chromosome = new Chromosome(pathLength);
            // Set the first city in the path as the startingCity
            chromosome.path[0] = startingCity;

            // Declare a new Set of unvisitedCities, and initialise it as a copy of the ArrayList of cityIDs
            Set<Integer> unvisitedCities = new HashSet<>(cities);
            // remove the startingCity from the set of unvisitedCities
            unvisitedCities.remove(startingCity);

            // for the length of the path
            for (int i = 1; i < pathLength; i++) {
                // initially set the closestCity to a random city from the set of unvisitedCities
                int closestCity = unvisitedCities.iterator().next();
                // loop through every unvisitedCity to find the closestCity
                for (Integer city : unvisitedCities) {
                    // if the distance between the currentCity and the unvisitedCity is < the distance between
                    // the currentCity and the closestCity
                    if (distanceMatrix[currentCity][city] < distanceMatrix[currentCity][closestCity]) {
                        // set thet unvisitedCity as the closestCity
                        closestCity = city;
                    }
                }
                // add the closestCity as the next city in the path
                chromosome.path[i] = closestCity;
                // make the currentCity for the next iteration the current closestCity
                currentCity = closestCity;
                // remove the closestCity from the set of unvisitedCities
                unvisitedCities.remove(closestCity);
            }

            // add the generated chromosome to the ArrayList of the initial nnPopulation
            nnPopualtion.add(chromosome);
        }

        return nnPopualtion;
    }
    // Method which returns a random initial population
    private static Set<Chromosome> generateRandomPopulation(int pathLength, int randomPopulationSize) {
        Set<Chromosome> population = new HashSet<>();

        // create an arraylist of CityIDs, and initialise it with the cities in order of their ID
        ArrayList<Integer> basePath = new ArrayList<>();
        for (int i = 0; i < pathLength; i++) {
            basePath.add(i);
        }

        // repeat the following for as many chromosomes as are required (populationSize)
        while (population.size() < randomPopulationSize) {
            Chromosome chromosome = new Chromosome(pathLength);
            // randomise the order of the arraylist of cities
            Collections.shuffle(basePath);
            for (int j = 0; j < pathLength; j++) {
                chromosome.path[j] = basePath.get(j);
            }
            population.add(chromosome);
        }

        return population;
    }


    private static void calculateFitnessOfPopulation(ArrayList<Chromosome> population) {
        // for every chromosome in the population
        for (Chromosome chromosome : population) {
            // if the fitness of the chromosome has not yet been calculated (i.e. is still -1)
            fitnessFunction(chromosome);
        }
    }
    private static void fitnessFunction(Chromosome chromosome) {
        chromosome.fitness = (double) ( (1/routeDistance(chromosome)) * 10000 );
    }
    private static double routeDistance(Chromosome chromosome) {
        double totalDistance = 0.0;

        // the sum of the distances between every 2 successive cities in a path
        for (int i = 0; i < chromosome.path.length-1; i++) {
            totalDistance += distanceMatrix[chromosome.path[i]][chromosome.path[i+1]];
        }
        // plus the distance between the last city in the path back to the first city in the path
        totalDistance += distanceMatrix[chromosome.path[chromosome.path.length-1]][chromosome.path[0]];

        return totalDistance;
    }


    // Method which performs crossover on the population
    private static Set<Chromosome> crossoverPopulation(ArrayList<Chromosome> population, int populationSize, int crossoverSize) {

        // declare a set of chromosomes which will store all thr chromosomes generated by the crossover operation
        Set<Chromosome> crossoverChromosomes = new HashSet<>();

        while (crossoverChromosomes.size() < crossoverSize) {
            // retrieve a set of chromosomes (of size 2) on which crossover will occur
            // using the Rank-Based Roulette Wheel Selection method
            Set<Chromosome> selectedChromosomes = rankBasedRouletteWheelSelection(population, populationSize);

            // store the 2 Chromosomes in parent 1 and parent 2
            Chromosome parent1 = selectedChromosomes.iterator().next();
            selectedChromosomes.remove(parent1);
            Chromosome parent2 = selectedChromosomes.iterator().next();

            // perform crossover using the crossoverChromosomes method
            // the method is called twice, switching the order of the parents for the second time, since SCX produces only
            // one child, however produces a different child when the parents are switched
            crossoverChromosomes.add(crossover(parent1, parent2));
            crossoverChromosomes.add(crossover(parent2, parent1));
        }

        return crossoverChromosomes;
    }
    private static Set<Chromosome> rankBasedRouletteWheelSelection(ArrayList<Chromosome> population, int populationSize) {
        // set of chromosomes/paths on which crossover will be carried out
        Set<Chromosome> selectedChromosomes = new HashSet<>();

        // calculate the sum of all ranks, which will be used as a denominator for all probabilities
        int sumOfRanks = (populationSize + 1) * populationSize / 2;

        // declare an array of cumulative probabilities for all the chromosomes in the population
        double[] cumulativeProbability = new double[populationSize];
        // calculate the cumulative probability of the first chromosome as its probability
        cumulativeProbability[0] = (double) populationSize / sumOfRanks;
        // calculate the cumulative probabilities of all successive chromosomes:
        for (int i = 1; i < populationSize; i++) {
            // as the probability of this chromosomes based on its rank
            double probability = (double) (populationSize-i) / sumOfRanks;
            // plus the cumulative proability of the preceeding chromosome
            cumulativeProbability[i] = cumulativeProbability[i-1] + probability;
        }

        while (selectedChromosomes.size() < 2) {
            // choose a chromosome randomly based on its cumulative probability (the lower the better)
            double random = ThreadLocalRandom.current().nextDouble();
            int choice = 0;
            while (random > cumulativeProbability[choice]) {
                choice++;
            }

            // add the chosen chromosome to the set of selectedChromosomes
            selectedChromosomes.add(population.get(choice));
        }

        return selectedChromosomes;
    }
    /*
    // Method which chooses which chromosomes will be used for crossover using Tournament Selection
    private static Set<Chromosome> tournamentSelection(ArrayList<Chromosome> population, int tournamentSize) {
        // set of chromosomes/paths on which crossover will be carried out
        Set<Chromosome> tournamentChromosomes = new HashSet<>();

        // carry out the tournament until the set of chromosomes selected from the tournament has reached the tournament size
        while (tournamentChromosomes.size() < tournamentSize) {
            // choose a random chromosome
            int c1 = ThreadLocalRandom.current().nextInt(0, population.size());
            // choose a random chromosome which is not c1
            int c2;
            do {
                c2 = ThreadLocalRandom.current().nextInt(0, population.size());
            } while (c1 == c2);

            // if chromosome1 has a higher fitness than chromosome 2
            if (population.get(c1).fitness > population.get(c2).fitness) {
                // then add chromosome1 to the set of tournament chromosomes
                tournamentChromosomes.add(population.get(c1));
            } else {
                // if not, add chromosome2 to the set
                tournamentChromosomes.add(population.get(c2));
            }
        }

        return tournamentChromosomes;
    }
    */
    private static Chromosome crossover(Chromosome parent1, Chromosome parent2) {

        // store the length of the paths
        int pathLength = parent1.path.length;

        // Declare a new Chromosome for the child, and set its path to be the same as its parents
        Chromosome child = new Chromosome(pathLength);
        // Declare a Set of visitedNodes, which will be used to check if a node is legitimate
        Set<Integer> visitedNodes = new HashSet<>();

        // set the first node in parent 1's path as the first node in the child path
        child.path[0] = parent1.path[0];
        // and add it to the set of visited ndoes
        visitedNodes.add(child.path[0]);

        // find the successor of current node in both parents
        for (int i = 0; i < pathLength-1; i++) {

            // declare and initialise the currentNode
            int currentNode = child.path[i];

            // store at what index in the path the current node is in
            int p1CurrentNodeIndex = -1;
            int p2CurrentNodeIndex = -1;

            // store the next legitimate node in a particular path
            int p1NextNode = -1;
            int p2NextNode = -1;

            // find the index of the current node in p1
            for (int j = 0; j < pathLength; j++) {
                if (parent1.path[j] == currentNode) {
                    p1CurrentNodeIndex = j;
                    break;
                }
            }
            // find the index of the current node in p2
            for (int j = 0; j < pathLength; j++) {
                if (parent2.path[j] == currentNode) {
                    p2CurrentNodeIndex = j;
                    break;
                }
            }

            // find the next legitimate node in p1
            for (int j = 1; j < pathLength; j++) {
                // set the index such that once it reaches the end of the chromosome it starts back from the end
                int index = p1CurrentNodeIndex + j;
                index = (index >= pathLength) ? index-pathLength : index;

                // if the node after is not already in the child chromosome, then it is legitimate
                if (!visitedNodes.contains(parent1.path[index])) {
                    // and set it as a candidate for the next node
                    p1NextNode = parent1.path[index];
                    break;
                }
            }
            // find the next legitimate node in p2
            for (int j = 1; j < pathLength; j++) {
                // set the index such that once it reaches the end of the chromosome it starts back from the end
                int index = p2CurrentNodeIndex + j;
                index = (index >= pathLength) ? index-pathLength : index;

                if (!visitedNodes.contains(parent2.path[index])) {
                    p2NextNode = parent2.path[index];
                    break;
                }
            }

            // if the distance between the current city and the next legitimate city in parent1
            // is shorter than the distance from current city to the next legitimate node in p2
            if (distanceMatrix[currentNode][p1NextNode] < distanceMatrix[currentNode][p2NextNode]) {
                child.path[i + 1] = p1NextNode;
                visitedNodes.add(p1NextNode);
            } else {
                child.path[i + 1] = p2NextNode;
                visitedNodes.add(p2NextNode);
            }
        }

        return child;
    }


    private static Set<Chromosome> mutatePopulation(Set<Chromosome> population, double mutationRate) {
        // declare a set of Chromosomes which will store the mutated chromosomes.
        // initialise it as a copy of the population (the children chromosomes)
        Set<Chromosome> mutatedChromosomes = new HashSet<>(population);

        for (Chromosome path : mutatedChromosomes) {
            double mutationProbability = ThreadLocalRandom.current().nextDouble();
            if (mutationProbability > (1-mutationRate)) {
                // mutate the path using the RSM mutation operator
                mutateRoute(path);
                // indicate that the fitness of this path needs to be recalculated
                path.fitness = -1;
            }
        }

        // The set will most probably include certain chromosomes which are already present in the set of children
        // however, given that both are sets, any duplicates will be discarded
        return mutatedChromosomes;
    }
    // method which performs Reverse Sequence Mutation (RSM) on a Chromosome
    private static void mutateRoute(Chromosome chromosome) {
        int pathLength = chromosome.path.length;

        // setting position a for the RSM mutation as a random city between the first and penultimate city in the route
        int a = ThreadLocalRandom.current().nextInt(0, pathLength-1);
        // setting position b for the RSM mutation as a random city between a and the last city in the route
        int b = ThreadLocalRandom.current().nextInt(a, pathLength);

        while (a < b){
            int temp = chromosome.path[a];
            chromosome.path[a] = chromosome.path[b];
            chromosome.path[b] = temp;

            a++;
            b--;
        }
    }


    // method which evolves the population. this method will take the current population, which includes the
    // last generation's population, the children, and some mutated children, introduces a new 'initial' population
    // and chooses the fittest chromosomes from the entire population for the next generation
    private static ArrayList<Chromosome> evolvePopulation(ArrayList<Chromosome> currentGeneration, int populationSize,
                                                          ArrayList<City> cities, int pathLength) {
        // declare a Set of Chromosomes which will store the Chromosomes that will be present in the next generation
        // ( i.e.the fittest )
        Set<Chromosome> nextGeneration = new HashSet<>();

        // add another set of nearest neighbour + randomly generated chromosomes to re-introduce diversity
        // and thus avoiding getting caught on local maxima
        currentGeneration.addAll(generatePopulation(cities, pathLength, populationSize));
        // calculate the fitness of all the Chromosomes in the population
        calculateFitnessOfPopulation(currentGeneration);
        // sort the population so that the chromosomes with the highest fitness are at the start of the list
        Collections.sort(currentGeneration);

        // keep adding chromosomes from the fittest of the currentGeneration until either the required population size is reached
        // or before an out of bounds occurs (i.e. not enough non-duplicate chromosomes
        int i = 0;
        while (nextGeneration.size() < populationSize && i < currentGeneration.size()) {
            nextGeneration.add(currentGeneration.get(i));
            i++;
        }

        // if the population size of the next generation is less than what it should be
        while (nextGeneration.size() < populationSize) {
            // keep adding an 'initial' population until it is of the required size
            nextGeneration.addAll(generatePopulation(cities, pathLength, populationSize-nextGeneration.size()));
        }

        return new ArrayList<>(nextGeneration);
    }



    // Methods used for debugging:
    public static void printPopulation(ArrayList<Chromosome> population) {
        for (Chromosome chromosome : population) {
            System.out.println(chromosome);
        }
    }
}
